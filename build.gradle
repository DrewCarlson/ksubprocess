plugins {
    id 'kotlin-multiplatform' version "$kotlin_version"
    id 'com.moowork.node' version "$gradle_node_version"
    id 'org.jetbrains.dokka' version "$dokka_version"
    id 'maven-publish'
}

repositories.whenObjectAdded {
    if (it instanceof IvyArtifactRepository) {
        metadataSources {
            artifact()
        }
    }
}

repositories {
    jcenter()
}

node {
    version = "$node_version"

    download = true
    nodeModulesDir = file(buildDir)
}

task prepareNodePackage(type: Copy) {
    from("npm") {
        include 'package.json'
        expand(project.properties + [kotlinDependency: ""])
    }
    from("npm") {
        exclude 'package.json'
    }
    into "$node.nodeModulesDir"
}

npmInstall.dependsOn prepareNodePackage

task installDependenciesMocha(type: NpmTask, dependsOn: npmInstall) {
    args = [
            'install',
            "mocha@$mocha_version",
//            "mocha-headless-chrome@$mocha_headless_chrome_version",
            "source-map-support@$source_map_support_version",
            '--no-save'
    ]
}



kotlin {
    jvm()
    js()
    // For ARM, should be changed to iosArm32 or iosArm64
    // For Linux, should be changed to e.g. linuxX64
    // For MacOS, should be changed to e.g. macosX64
    // For Windows, should be changed to e.g. mingwX64
    linuxX64("linux") { // Replace with a target you need.
        compilations.main {
            cinterops {
                runprocess {
                    // Def-file describing the native API.
                    defFile project.file("src/linuxMain/cinterop/runprocess.def")
                }
            }
        }
    }
    mingwX64("windows")

    sourceSets {
        commonMain {
            dependencies {
                implementation kotlin('stdlib-common')
                api "org.jetbrains.kotlinx:kotlinx-io:$kotlinx_io_version"
            }
        }
        commonTest {
            dependencies {
                implementation kotlin('test-common')
                implementation kotlin('test-annotations-common')
            }
        }
        jvmMain {
            dependencies {
                implementation kotlin('stdlib-jdk8')
                api "org.jetbrains.kotlinx:kotlinx-io-jvm:$kotlinx_io_version"
            }
        }
        jvmTest {
            dependencies {
                implementation kotlin('test')
                implementation kotlin('test-junit')
            }
        }
        jsMain {
            dependencies {
                implementation kotlin('stdlib-js')
                api "org.jetbrains.kotlinx:kotlinx-io-js:$kotlinx_io_version"
            }
        }
        jsTest {
            dependencies {
                implementation kotlin('test-js')
            }
        }
        linuxMain {
            dependencies {
                api "org.jetbrains.kotlinx:kotlinx-io-native:$kotlinx_io_version"
            }

        }
        windowsMain {
            dependencies {
                api "org.jetbrains.kotlinx:kotlinx-io-native:$kotlinx_io_version"
            }
        }
    }

    kotlin.sourceSets.all {
        languageSettings {
            useExperimentalAnnotation('kotlin.Experimental')
        }
    }
}

compileKotlinJs {
    kotlinOptions.metaInfo = true
    kotlinOptions.sourceMap = true
    kotlinOptions.moduleKind = 'umd'
    kotlinOptions.main = "noCall"
    kotlinOptions.sourceMapEmbedSources = 'always'
}

compileTestKotlinJs {
    kotlinOptions.metaInfo = true
    kotlinOptions.sourceMap = true
    kotlinOptions.moduleKind = 'umd'
    kotlinOptions.main = "call"
    kotlinOptions.sourceMapEmbedSources = 'always'
}

linuxTest {
    // expected in the environment test
    environment['TEST'] = 'TESTVAL'

    // required for subprocess tests
    dependsOn ":testprograms:jar"
    environment['PT_JAVA_EXE'] = jvmTest.executable
    doFirst {
        environment['PT_JAR'] = project(":testprograms").tasks["jar"].archiveFile.get()
    }

}

windowsTest {
    // expected in the environment test
    environment['TEST'] = 'TESTVAL'

    // required for subprocess tests
    dependsOn ":testprograms:jar"
    environment['PT_JAVA_EXE'] = jvmTest.executable
    doFirst {
        environment['PT_JAR'] = project(":testprograms").tasks["jar"].archiveFile.get()
    }
}

jvmTest {
    // expected in the environment test
    environment['TEST'] = 'TESTVAL'

    // required for subprocess tests
    dependsOn ":testprograms:jar"
    environment['PT_JAVA_EXE'] = jvmTest.executable
    doFirst {
        environment['PT_JAR'] = project(":testprograms").tasks["jar"].archiveFile.get()
    }
}


// must manually copy js dependencies for this to work
task copyJsDependencies(type: Copy, dependsOn: compileTestKotlinJs) {
    from compileKotlinJs.destinationDir
    into "${buildDir}/node_modules"

    def configuration = configurations.jsTestRuntimeClasspath
    from(files {
        configuration.collect { File file ->
            file.name.endsWith(".jar")
                    ? zipTree(file.absolutePath).matching {
                include '*.js'
                include '*.js.map'
            }
                    : files()
        }
    }.builtBy(configuration))
}

// test js with mocha
task runMocha(type: NodeTask, dependsOn: [installDependenciesMocha, jsMainClasses, jsTestClasses, copyJsDependencies], group: 'npm') {
    // expected in the environment test
    def env = ['TEST': 'TESTVAL']

    // required for subprocess tests
    dependsOn ":testprograms:jar"
    env['PT_JAVA_EXE'] = jvmTest.executable
    doFirst {
        env['PT_JAR'] = project(":testprograms").tasks["jar"].archiveFile.get()
        environment = env
    }


    // node execution settings
    script = file("$node.nodeModulesDir/node_modules/mocha/bin/mocha")
    args = [compileTestKotlinJs.outputFile, '--require', 'source-map-support/register']
    // excludes ProcessTests and ExecTests since Process isn't done yet
    args += ['-i', '-g', 'ProcessTests|ExecTests']
}
jsTest.dependsOn runMocha

dokka {
    outputFormat = 'html'
    outputDirectory = "$buildDir/dokka"

    configuration {
        includes = ['src/PACKAGES.md']
        jdkVersion = 8
    }

    impliedPlatforms = ["Common"] // This will force platform tags for all non-common sources e.g. "JVM"
    multiplatform {
        common {
            // nothing special for common
        }

        jvm {
            targets = ["JVM"]
        }
        js {
            targets = ["JS"]
        }
        linux {
            targets = ["Linux"]
        }
        windows {
            targets = ["Windows"]
        }
    }
}


def pomConfig = {
    url 'https://github.com/xfel/ksubprocess'

    licenses {
        license {
            name "The Apache Software License, Version 2.0"
            url "http://www.apache.org/licenses/LICENSE-2.0.txt"
            distribution "repo"
        }
    }
    developers {
        developer {
            id "xfel"
            name "Felix Treede"
            email "felixtreede@yahoo.de"
        }
    }

    scm {
        url "https://github.com/xfel/ksubprocess.git"
    }
}

publishing {
    repositories {
        maven {
            def user = 'xfelde'
            def repo = 'ksubprocess'
            def name = 'ksubprocess'
            url = "https://api.bintray.com/maven/$user/$repo/$name/;publish=0"

            credentials {
                username = System.getProperty('bintray.user')
                password = System.getProperty('bintray.key')
            }
        }
    }
    publications {
        jvm {
            pom.withXml {
                def root = asNode()
                root.appendNode('description', 'Kotlin/JVM child process library')
                root.appendNode('name', 'Kotlin child process library - JVM module')
                root.children().last() + pomConfig
            }
        }
        js {
            pom.withXml {
                def root = asNode()
                root.appendNode('description', 'Kotlin/JS child process library')
                root.appendNode('name', 'Kotlin child process library - JS module')
                root.children().last() + pomConfig
            }
        }
        linux {
            pom.withXml {
                def root = asNode()
                root.appendNode('description', 'Kotlin/Native linux child process library')
                root.appendNode('name', 'Kotlin child process library - Native/Linux module')
                root.children().last() + pomConfig
            }
        }
        windows {
            pom.withXml {
                def root = asNode()
                root.appendNode('description', 'Kotlin/Native windows child process library')
                root.appendNode('name', 'Kotlin child process library - Native/Windows module')
                root.children().last() + pomConfig
            }
        }
        kotlinMultiplatform {
            pom.withXml {
                def root = asNode()
                root.appendNode('description', 'Kotlin multiplatform child process library')
                root.appendNode('name', 'Kotlin child process library - Multiplatform')
                root.children().last() + pomConfig
            }
        }
        metadata {
            pom.withXml {
                def root = asNode()
                root.appendNode('description', 'Kotlin multiplatform child process library')
                root.appendNode('name', 'Kotlin child process library - Metadata')
                root.children().last() + pomConfig
            }
        }
    }
}
